# Used to write routines into the game ROM


AP_BASE_ROUTINE = bytearray([
    0xE5, 	#	  PUSH HL
    0xF5, 	#	  PUSH AF
    0xC5, 	#	  PUSH BC
    0xD5, 	#	  PUSH DE
    0xCD, 0x00, 0x7C, 	#	  CALL $7C00
        #	  
    0xFA, 0x4B, 0xD5, 	#	  LD A, ($D54B)
    0xE6, 0x01, 	#	  AND $01
    0x20, 0x2E, 	#	  JR NZ, exit
    0xFA, 0xAC, 0xD4, 	#	  LD A, ($D4AC)
    0xFE, 0x06, 	#	  CP $06
    0x30, 0x27, 	#	  JR NC, exit
    0xE6, 0x01, # AND $01
    0x28, 0x23, # JR Z, exit
    0xFA, 0xF0, 0xDA, 	#	  LD A, ($DAF0)
    0xE6, 0x0F, 	#	  AND $0F
    0x28, 0x1C, 	#	  JR Z, exit
        #	  
    0xF5, 	#	  PUSH AF
    0xCB, 0x27, 	#	  SLA A
    0x01, 0x80, 0x7C, 	#	  LD BC, $7C80
    0x81, 	#	  ADD A, C
    0x4F, 	#	  LD C, A
    0x0A, 	#	  LD A, (BC)
    0x67, 	#	  LD H, A
    0x0C, 	#	  INC C
    0x0A, 	#	  LD A, (BC)
    0x6F, 	#	  LD L, A
    0xF1, 	#	  POP AF
    0x01, 0xA0, 0x7C, 	#	  LD BC, $7CA0
    0x81, 	#	  ADD A, C
    0x4F, 	#	  LD C, A
    0x0A, 	#	  LD A, (BC)
    0xCD, 0x40, 0x37, 	#	  CALL $3740
    0x3E, 0x00, 	#	  LD A, $00
    0xEA, 0xF0, 0xDA, 	#	  LD ($DAF0), A
        #	  exit:
    0xD1, 	#	  POP DE
    0xC1, 	#	  POP BC
    0xF1, 	#	  POP AF
    0xE1, 	#	  POP HL
    0xCD, 0x4C, 0x0B, 	#	  CALL $0B4C
    0xC9,	#	  RET



])

AREA_SELECT = bytearray([
    0xE5,	#	  PUSH HL
    0xFA,0xAC,0xD4,	#	  LD A, ($D4AC)
    0xE6,0x04,	#	  AND $04
    0x28,0x09,	#	  JR Z, redtbl
    0x06,0x01,	#	  LD B, $01
    0x21,0xD0,0xDA,	#	  LD HL, $DAD0
    0x4D,	#	  LD C, L
    0xC3,0x97,0x7B,	#	  JP areas
        #	  redtbl:
    0x06,0x00,	#	  LD B, $00
    0x21,0xB0,0xDA,	#	  LD HL, $DAB0
    0x4D,	#	  LD C, L
        #	  areas:
        #	  
    0xFA,0x4A,0xD5,	#	  LD A, ($D54A)
    0x57,	#	  LD D, A
        #	  nextarea:
    0x7A,	#	  LD A, D
    0x69,	#	  LD L, C
    0x3C,	#	  INC A
    0x57,	#	  LD D, A
    0xFE,0x12,	#	  CP $12
    0x20,0x04,	#	  JR NZ, checkstage
    0x78,	#	  LD A, B
    0xC3,0xB1,0x7B,	#	  JP setbasestage
        #	  
        #	  checkstage:
    0x57,	#	  LD D, A
    0x4D,	#	  LD C, L
    0x85,	#	  ADD A, L
    0x6F,	#	  LD L, A
    0x7E,	#	  LD A, (HL)
    0xE6,0xFF,	#	  AND $FF
    0x28,0xEB,	#	  JR Z, nextarea
        #	
        #	  setstage:
    0x7A,	#	  LD A, D
        #	  setbasestage:
    0xEA,0x4A,0xD5,	#	  LD ($D54A), A
    0xE6,0xFF,	#	  AND $FF
    0xCE,0x29,	#	  ADC A, $29
    0xCD,0x78,0x71,	#	  CALL $7178
        #	  exit:
    0xE1,	#	  POP HL
    0xC9,	#	  RET

])
CHECK_MOVE  = bytearray([
    0xFA, 0x99, 0xFF, 	#	  LD A, ($FF99)
    0xE6, 0x04, 	#	  AND $04
    0x28, 0x1F, 	#	  JR Z, checkslot
    0xFA, 0x4B, 0xD5, 	#	  LD A, ($D54B)
    0xE6, 0x01, 	#	  AND $01
    0x20, 0x18, 	#	  JR NZ, checkslot
    0xFA, 0xAC, 0xD4, 	#	  LD A, ($D4AC)
    0xFE, 0x06, 	#	  CP $06
    0x30, 0x11, 	#	  JR NC, checkslot
    0xE6, 0x01, 	#	  AND $01
    0x28, 0x0D, 	#	  JR Z, checkslot
    0xFA, 0x04, 0xD6, 	#	  LD A, ($D604)
    0xE6, 0x01, 	#	  AND $01
    0x20, 0x06, 	#	  JR NZ, checkslot
    
    0xFA, 0x4B, 0xD5, 	#	  LD A, ($D54B)
    0xCD, 0x80, 0x7B, # CALL $7B80
            #	  checkslot:
    0xC9, # RET
])

DOUBLE_TIME = bytearray([
    0x79,	#	  LD A, C
    0xCB,0x27,	#	  SLA A
    0xFE, 0x60, # CP $60
    0x20, 0x05, # JR NZ, $4F12
    0x78,  # LD A, B
    0x3C, # INC A
    0x47, # LD B, A
    0x3E, 0x00, #  LD A, $00
    0xEA,0x7A,0xD5,	#	  LD ($D57A), A
    0x78,	#	  LD A, B
    0xCB,0x27,	#	  SLA A
    0xEA,0x7B,0xD5,	#	  LD ($D57B), A
    
    0xC9,	#	  RET

])
RESTRICT_MAP_MOVE_R = bytearray([
    0x3E, 0x11, # LD A, $11
    0xEA, 0xF1, 0xDA, # LD ($DAF1), A
    0xC9, # RET
    0x00, 0x00, 0x00, 0x00, 0x00, # NOP x11
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00
])
RESTRICT_MAP_MOVE_B = bytearray([
    0x3E, 0x11, # LD A, $11
    0xEA, 0xF2, 0xDA, # LD ($DAF2), A
    0xC9, # RET
    0x00, 0x00, 0x00, 0x00, 0x00, # NOP x10
    0x00, 0x00, 0x00, 0x00, 0x00,
])

SWAP_TABLE = bytearray([
    0xFA, 0x98, 0xFF, 	#	LD A, ($FF98)
    0xE6, 0x04, 	#	  AND $04
    0x28, 0x11, 	#	  JR Z, exitnormal
    0xFA, 0xAC, 0xD4, 	#	  LD A, ($D4AC)
    0xE6, 0x04, 	#	  AND $04
    0x28, 0x05, 	#	  JR Z, redtable
    0x3E, 0x01, 	#	  LD A, $01
    0xC3, 0x5C, 0x7C, 	#	  JP exitchange
        #	  redtable:
    0x3E, 0x05, 	#	  LD A, $05
    0xC3, 0x5C, 0x7C, 	#	  JP exitchange
        #	  exitnormal:
    0xFA, 0x97, 0xD4, 	#	  LD A, ($D497)
    0xC9, 	#	  RET
        #	  exitchange:
    0xC5, 	#	  PUSH BC
    0xE5, 	#	  PUSH HL
    0xD5, 	#	  PUSH DE
    0x57, 	#	  LD D, A
    0xFA, 0x60, 0xD4, 	#	  LD A, ($D460)
    0xE6, 0xFF, 	#	  AND $FF
    0x28, 0x11, 	#	  JR Z, exitloop
    0x5F, 	#	  LD E, A
    0xEA, 0xFF, 0xDA, 	#	  LD ($DAFF), A
    0x21, 0x00, 0xD3, 	#	  LD HL, $D300
    0x01, 0x00, 0xDB, 	#	  LD BC, $DB00
        #	  loopparty:
    0x7E, 	#	  LD A, (HL)
    0x02, 	#	  LD (BC), A
    0x2C, 	#	  INC L
    0x0C, 	#	  INC C
    0x1D, 	#	  DEC E
    0x20, 0xF9, 	#	  JR NZ, loopparty
        #	  exitloop:
    0x7A, 	#	  LD A, D
    0xD1, 	#	  POP DE
    0xE1, 	#	  POP HL
    0xC1, 	#	  POP BC
    0xC9,	#	  RET


])
RESTORE_PARTY = bytearray([
    0xFA, 0xFF, 0xDA, 	#	LD A, ($DAFF)
    0xE6, 0xFF, 	#	AND $FF
    0x28, 0x18, 	#	JR Z, exit
    0xE5, 	#	PUSH HL
    0xC5, 	#	PUSH BC
    0xD5, 	#	PUSH DE
    0x5F, 	#	LD E, A
    0xEA, 0x60, 0xD4, 	#	LD ($D460), A
    0x21, 0x00, 0xDB, 	#	LD HL, $DB00
    0x01, 0x00, 0xD3, 	#	LD BC, $D300
        #	loop:
    0x7E, 	#	LD A, (HL)
    0x02, 	#	LD (BC), A
    0x3E, 0x00, 	#	LD A, $00
    0x77, 	#	LD (HL), A
    0x1D, 	#	DEC E
    0x20, 0xF8, 	#	JR NZ, loop
        #	endloop:
    0xD1, 	#	POP DE
    0xC1, 	#	POP BC
    0xE1, 	#	POP HL
        #	exit:
    0x3E, 0x00, 	#	LD A, $00
    0xEA, 0xFF, 0xDA, 	#	LD ($DAFF), A
    0xFA, 0xC1, 0xD7, 	#	LD A, ($D7C1)
    0xC9,	#	RET

])

NEW_CATCHEM = bytearray([
    0xF5, 	#	  PUSH AF
    0xE5, 	#	  PUSH HL
    0xC5, 	#	  PUSH BC
    0x21, 0x00, 0xD3, 	#	  LD HL, $D300
    0x47, 	#	  LD B, A
    0xFA, 0xF5, 0xDA, 	#	  LD A, ($DAF5)
    0xFE, 0x10, 	#	  CP $10
    0x28, 0x10, 	#	  JR Z, exitgoodmon
    0xFA, 0x60, 0xD4, 	#	  LD A, ($D460)
    0x4F, 	#	  LD C, A
    0xE6, 0xFF, 	#	  AND $FF
    0x28, 0x08, 	#	  JR Z, exitgoodmon
        #	loop:
    0x7E, 	#	  LD A, (HL)
    0xB8, 	#	  CP B
    0x28, 0x12, 	#	  JR Z, exitbadmon
    0x23, 	#	  INC HL
    0x0D, 	#	  DEC C
    0x20, 0xF8, 	#	  JR NZ, loop
        #	exitgoodmon:
    0x3E, 0x00, 	#	  LD A, $00
    0xEA, 0xF5, 0xDA, 	#	  LD ($DAF5), A
    0xC1, 	#	  POP BC
    0xE1, 	#	  POP HL
    0xF1, 	#	  POP AF
    0xEA, 0x79, 0xD5, 	#	  LD ($D579), A
    0xFE, 0xA0, 	#	  CP $A0
    0xC9, 	#	  RET
        #	  exitbadmon:
    0xFA, 0xF5, 0xDA, 	#	  LD A, ($DAF5)
    0x3C, 	#	  INC A
    0xEA, 0xF5, 0xDA, 	#	  LD ($DAF5), A
    0xC1, 	#	  POP BC
    0xE1, 	#	  POP HL
    0xF1, 	#	  POP AF
    0xE6, 0x00, 	#	  AND $00
    0xC9,	#	  RET

])
CALL_BANKSWITCH = bytearray([
    0xC5, 	#	PUSH BC
    0x47, # LD B, A
    0xFA, 0xF8, 0xFF, # LD A, ($FFF8)
    0xEA, 0xF6, 0xDA, # LD ($DAF6), A
    0x78, # LD A, B
    0x01, 0x51, 0x37, 	#	LD BC, returnpoint
    0xC5, 	#	PUSH BC
    0xEA, 0x00, 0x20, 	#	LD ($2000), A
        #	
    0xE9, 	#	JP HL
        #	returnpoint:
    0xC1, 	#	POP BC
    0xFA, 0xF6, 0xDA, 	#	LD A, ($DAF6)
    0xEA, 0x00, 0x20, 	#	LD ($2000), A
    0xC9,	#	RET

])
EVO_ITEM = bytearray([
    0x00
])